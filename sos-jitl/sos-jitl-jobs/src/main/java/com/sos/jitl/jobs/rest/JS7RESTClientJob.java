package com.sos.jitl.jobs.rest;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.sos.commons.httpclient.exception.SOSBadRequestException;
import com.sos.commons.httpclient.exception.SOSConnectionRefusedException;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.sos.js7.job.Job;
import com.sos.js7.job.OrderProcessStep;
import com.sos.js7.job.OrderProcessStepLogger;
import com.sos.js7.job.exception.JobArgumentException;
import com.sos.js7.job.exception.JobException;
import com.sos.js7.job.exception.JobRequiredArgumentMissingException;
import com.sos.js7.job.jocapi.ApiExecutor;
import com.sos.js7.job.jocapi.ApiResponse;
import net.thisptr.jackson.jq.Scope;
import net.thisptr.jackson.jq.BuiltinFunctionLoader;
import net.thisptr.jackson.jq.Versions;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

public class JS7RESTClientJob extends Job<JS7RESTClientJobArguments> {

    public static final ObjectMapper objectMapper;
    private static final Scope rootScope;

    public void processOrder(OrderProcessStep<JS7RESTClientJobArguments> step) throws Exception {
        JS7RESTClientJobArguments myArgs = step.getDeclaredArguments();
        OrderProcessStepLogger logger = step.getLogger();

        //Check the request JSON
        String requestJson = (String) myArgs.getMyRequest().getValue();
        logger.info("Request Body : " +requestJson);
        if (requestJson != null && !requestJson.isBlank()) {
            JsonNode requestNode;
            try {
                requestNode = objectMapper.readTree(requestJson);
            } catch (Exception e) {
                throw new JobException("Invalid JSON in 'myRequest': " + e.getMessage(), e);
            }

            String endpoint = requestNode.has("endpoint") ? requestNode.get("endpoint").asText(null) : null;
            if (endpoint == null || endpoint.isBlank()) {
                throw new JobRequiredArgumentMissingException("Missing or empty 'endpoint' in request JSON.");
            }

            logger.info("Endpoint: " + endpoint);

            String bodyStr = null;
            if (requestNode.has("body")) {
                try {
                    JsonNode bodyNode = requestNode.get("body");
                    if (bodyNode != null) {
                        bodyStr = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(bodyNode);
                        logger.info("Body:" + bodyStr);
                    }
                } catch (Exception e) {
                    throw new JobException("Failed to extract 'body' from request JSON: " + e.getMessage(), e);
                }
            }

            Map<String, String> headers = new HashMap<>();

            if (requestNode.has("headers") && requestNode.get("headers").isArray()) {
                for (JsonNode headerNode : requestNode.get("headers")) {
                    if (headerNode.has("key") && headerNode.has("value")) {
                        String key = headerNode.get("key").asText();
                        String value = headerNode.get("value").asText();
                        headers.put(key, value);
                    }
                }
            }


            ApiExecutor apiExecutor = new ApiExecutor(step);
            String accessToken = null;
            ApiResponse response = null;
            boolean loginSuccessful = false;
            boolean logoutSuccessful = false;

            try {
                //REST Call -Creating a new session by login method
                response = apiExecutor.login();
                if (response == null || response.getStatusCode() != 200) {
                    String body = response != null ? response.getResponseBody() : "No response";
                    throw new JobException("Login failed. " + body);
                }
                loginSuccessful = true;
                logger.info("Login successful.");

                accessToken = response.getAccessToken();

                //Sending the REST request to the specified endpoint with body and access_token( generated by login in new session)
                response = apiExecutor.post(accessToken, endpoint, bodyStr, headers);
                int statusCode = response.getStatusCode();

                if (statusCode < 200 || statusCode >= 300) {
                    logger.error("Request failed with status code: " + statusCode + ". Response: " + response.getResponseBody());
                    if (statusCode == 420) {
                        throw new JobException("JS7 API Throttling (420): " + response.getResponseBody());
                    }
                    throw new JobException("Unexpected status code: " + statusCode);
                }

                logger.info("REST call successful. Status Code: " + statusCode);

                String targetFilePath = (String) step.getOutcome().getVariables().get("js7ApiExecutorOutfile");
                if (targetFilePath != null && !targetFilePath.isEmpty() && Files.exists(Paths.get(targetFilePath))) {
                    logger.info("Export to File: " + targetFilePath);
                }

                // Extract content-type header (case-insensitive)
                Map<String, String> resHeaders = apiExecutor.getResponseHeaders();
                String contentType = null;
                for (Map.Entry<String, String> entry : resHeaders.entrySet()) {
                    if ("content-type".equalsIgnoreCase(entry.getKey())) {
                        contentType = entry.getValue();
                        break;
                    }
                }
                if (!resHeaders.isEmpty()) {
                    StringBuilder headerLog = new StringBuilder("Response Headers:\n");
                    resHeaders.forEach((key, value) -> headerLog.append("  ").append(key).append(": ").append(value).append("\n"));
                    logger.info(headerLog.toString().trim());
                }

                String jqQuery = null;
                String pI = null;
                String filePath = null;
                String name = null;
                String path = null;
                JsonNode responseJson = null;
                String inputOption = null;
                boolean rawOutput = false;
                String returnVarJson = myArgs.getReturnVariable().getValue();
                String responseBody = response.getResponseBody();

                if (responseBody != null && !responseBody.trim().isEmpty()) {
                    if ("application/json".equalsIgnoreCase(contentType)) {
                        responseJson = objectMapper.readTree(response.getResponseBody());
                        logger.debug("Response Body: " + objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(responseJson));
                    } else {
                        logger.debug("Response Body : \n" + response.getResponseBody());
                    }
                }

                //Return variable -
                // check if return variable is available or not
                if (returnVarJson != null && !returnVarJson.trim().isEmpty()) {
                    JsonNode returnVars;
                    try {
                        returnVars = objectMapper.readTree(returnVarJson);
                    } catch (Exception e) {
                        throw new JobException("Invalid JSON in 'return_variable': " + e.getMessage(), e);
                    }

                    //check if it is a valid json array or not
                    if (returnVars.isArray()) {

                        ReturnVariableUtils.checkDuplicateReturnVariable(returnVars);
                        for (JsonNode mappingNode : returnVars) {
                            jqQuery = null;
                            pI = null;
                            filePath = null;
                            name = null;
                            path = null;
                            inputOption = null;
                            rawOutput = false;

                            name = mappingNode.has("name") ? mappingNode.get("name").asText().trim() : null;
                            path = mappingNode.has("path") ? mappingNode.get("path").asText().trim() : null;

                            //check if the JSON object have both name and path
                            if (name != null && !name.isBlank() && path != null && !path.isBlank()) {
                                String inputType = "json"; // default

                                if (path.startsWith("<")) {
                                    int firstSeparator = path.indexOf("||");

                                    if (firstSeparator == -1 && !path.matches("^<\\s*plain\\s*:??\\s*$")) {
                                        throw new JobArgumentException("Could not create return variable: " + name +
                                                ". Invalid path format: Missing '||' after input option or unknown input type: " + path);
                                    }

                                    if (firstSeparator != -1) {
                                        String inputSegment = path.substring(1, firstSeparator).trim(); // skip '<'
                                        path = path.substring(firstSeparator + 2).trim(); // rest: jq or file ops or both

                                        if (inputSegment.startsWith("plain:")) {
                                            inputType = "plain";
                                            inputOption = inputSegment.substring("plain:".length()).trim();
                                        } else if (inputSegment.startsWith("json:")) {
                                            inputType = "json";
                                            inputOption = inputSegment.substring("json:".length()).trim();
                                        } else if (inputSegment.matches("^plain\\s*:??\\s*")) {
                                            inputType = "plain";
                                            inputOption = "--response-body";
                                        } else {
                                            inputOption = inputSegment;
                                        }
                                        if (inputOption == null || inputOption.isEmpty()) {
                                            inputOption = "--response-body";
                                        }

                                    } else {
                                        // No || after input type, assume just "< plain"
                                        inputType = "plain";
                                        inputOption = "--response-body";
                                        path = ""; // no jq, no PI
                                    }
                                } else {
                                    // No < at all: default input type and option
                                    inputType = "json";
                                    inputOption = "--response-body";
                                }
                                 // Now handle split into jq query and file ops
                                String[] parts = path.split("\\|\\|", 2);
                                if(parts.length > 0 && (( inputType.equals("plain") && !parts[0].trim().startsWith(">") &&  !parts[0].trim().startsWith("-r"))||inputType.equals("json") )){
                                    jqQuery = parts[0].trim();
                                }

                                if (parts.length > 1 || (parts.length == 1 && (
                                        parts[0].trim().startsWith(">")
                                                || parts[0].trim().startsWith(">>")
                                                || parts[0].trim().startsWith("-r")
                                                || parts[0].trim().startsWith("--raw-output")))) {

                                    String processorString = (parts.length > 1) ? parts[1].trim() : parts[0].trim();
                                    String[] processorParts = processorString.split("\\s+");

                                    for (int i = 0; i < processorParts.length; i++) {
                                        String token = processorParts[i].trim();

                                        if (token.equals("-r") || token.equals("--raw-output")) {
                                            rawOutput = true;
                                        } else if ((token.equals(">") || token.equals(">>")) && i + 1 < processorParts.length) {
                                            String potentialFilePath = processorParts[i + 1].trim();
                                            if (potentialFilePath.startsWith("-")) {
                                                throw new JobArgumentException("Could not create return variable: " + name +
                                                        ". Invalid file path: found flag instead of file name after '" + token + "'");
                                            }
                                            pI = token;
                                            filePath = potentialFilePath;
                                            i++;
                                        } else if (token.matches("^[A-Za-z]:\\\\.*|^/.*")) {
                                            throw new JobArgumentException("File path provided without Processing Instruction (>, >>): " + token);
                                        }
                                    }
                                }


                                // check if jq is not null
                                if(jqQuery!=null && !jqQuery.trim().isEmpty()){
                                    JsonNode jqInput = null;
                                    ObjectNode mergedInput = objectMapper.createObjectNode();
                                    List<JsonNode> result=null;
                                    if (Objects.equals(inputType, "plain")) {
                                        if (responseBody != null && !responseBody.trim().isEmpty()) {
                                            if (contentType != null && contentType.toLowerCase().startsWith("text/")) {
                                                try {
                                                    // Escape inner quotes and wrap in double quotes to create valid JSON string.
                                                    //String escaped = responseBody.replace("\"", "\\\"");
                                                    jqInput = objectMapper.readTree("\"" + responseBody + "\"");
                                                } catch (Exception e) {
                                                    throw new JobArgumentException("Could not convert plain response body to JSON string: " + e.getMessage(), e);
                                                }
                                            } else {
                                                throw new JobArgumentException("Response body is not of content type text/*: " + contentType);
                                            }
                                        } else {
                                            throw new JobException("Empty Response Body!");
                                        }
                                        result=ReturnVariableUtils.runJqQuery(jqInput,jqQuery, rootScope, name);
                                    }
                                    else {
                                        String[] inputOptions = new String[0];
                                        if (inputOption != null && !inputOption.trim().isEmpty()) {
                                            inputOptions = inputOption.trim().split("\\s+");
                                        }
                                        if (inputOptions.length > 0) {
                                            if (responseBody != null && !responseBody.trim().isEmpty()) {
                                                if ("application/json".equalsIgnoreCase(contentType)) {
                                                    jqInput = objectMapper.readTree(responseBody);
                                                    if (jqInput.isObject()) {
                                                        mergedInput.setAll((ObjectNode) jqInput);
                                                    }
                                                }
                                            }
                                            for (String opt : inputOptions) {
                                                if (opt.startsWith("--response-body") || opt.startsWith("-b"))continue;
                                                else if (opt.startsWith("--response-header=") || opt.startsWith("-s=")) {
                                                    String headerName = opt.startsWith("--response-header=")
                                                            ? opt.substring("--response-header=".length()).trim().toLowerCase()
                                                            : opt.substring("-s=".length()).trim().toLowerCase();

                                                    String headerValue = resHeaders.entrySet().stream()
                                                            .filter(e -> e.getKey().equalsIgnoreCase(headerName))
                                                            .map(Map.Entry::getValue)
                                                            .findFirst().orElse(null);

                                                    if (headerValue != null) {
                                                        ObjectNode headerNode = objectMapper.createObjectNode();
                                                        headerNode.put(headerName, headerValue);
                                                        ObjectNode wrapper = objectMapper.createObjectNode();
                                                        wrapper.set("js7ResponseHeader", headerNode);
                                                        jqInput = wrapper;
                                                    } else {
                                                        throw new JobArgumentException("Could not create return variable: " + name + " because response header not found: " + headerName);
                                                    }

                                                }
                                                else if (opt.equals("--response-header") || opt.equals("-s")) {
                                                    ObjectNode headerObject = objectMapper.createObjectNode();
                                                    for (Map.Entry<String, String> entry : resHeaders.entrySet()) {
                                                        headerObject.put(entry.getKey(), entry.getValue().toLowerCase());
                                                    }
                                                    mergedInput.set("js7ResponseHeader", headerObject);

                                                }
                                                else if (opt.startsWith("--request-header=") || opt.startsWith("-q=")) {
                                                    String headerName = opt.startsWith("--request-header=")
                                                            ? opt.substring("--request-header=".length()).trim().toLowerCase()
                                                            : opt.substring("-q=".length()).trim().toLowerCase();

                                                    String headerValue = headers.entrySet().stream()
                                                            .filter(e -> e.getKey().equalsIgnoreCase(headerName))
                                                            .map(Map.Entry::getValue)
                                                            .findFirst().orElse(null);

                                                    if (headerValue != null) {
                                                        ObjectNode headerNode = objectMapper.createObjectNode();
                                                        headerNode.put(headerName, headerValue);
                                                        ObjectNode wrapper = objectMapper.createObjectNode();
                                                        wrapper.set("js7RequestHeader", headerNode);
                                                        jqInput = wrapper;
                                                    } else {
                                                        throw new JobArgumentException("Could not create return variable: " + name + " because request header not found: " + headerName);
                                                    }

                                                }
                                                else if (opt.equals("--request-header") || opt.equals("-q")) {
                                                    ObjectNode headerObject = objectMapper.createObjectNode();
                                                    for (Map.Entry<String, String> entry : headers.entrySet()) {
                                                        headerObject.put(entry.getKey(), entry.getValue().toLowerCase());
                                                    }
                                                    mergedInput.set("js7RequestHeader", headerObject);

                                                }
                                                else if (opt.equals("--request-body") || opt.equals("-d")) {
                                                    if (bodyStr != null && !bodyStr.trim().isEmpty()) {
                                                        JsonNode requestBodyJson = objectMapper.readTree(bodyStr);
                                                        if (!requestBodyJson.isObject()) {
                                                            throw new JobArgumentException("Request body must be a JSON object. Found: " + requestBodyJson.getNodeType());
                                                        }
                                                        mergedInput.set("js7RequestBody", requestBodyJson);
                                                    } else {
                                                        throw new JobArgumentException("Empty request body, could not create return variable: " + name);
                                                    }

                                                }
                                                else if (opt.startsWith("--from-json=") || opt.startsWith("-j=")) {
                                                    String jsonStr = opt.substring(opt.indexOf('=') + 1).trim();
                                                    try {
                                                        JsonNode fromJsonNode = objectMapper.readTree(jsonStr);

                                                        if (!fromJsonNode.isObject()) {
                                                            throw new JobArgumentException(" Expected JSON object for --from-json, but found: " + fromJsonNode.getNodeType());
                                                        }

                                                        // Check for duplicate keys before merging
                                                        Iterator<String> fieldNames = fromJsonNode.fieldNames();
                                                        while (fieldNames.hasNext()) {
                                                            String fieldName = fieldNames.next();
                                                            if (mergedInput.has(fieldName)) {
                                                                throw new JobArgumentException("Key conflict during input merge: " + fieldName);
                                                            }
                                                        }

                                                        ((ObjectNode) mergedInput).setAll((ObjectNode) fromJsonNode);

                                                    } catch (Exception e) {
                                                        logger.error("Invalid JSON for input option: " + jsonStr, e);
                                                        throw e;
                                                    }
                                                }
                                                else {
                                                    throw new JobArgumentException("Could not create return variable: " + name + ". Unsupported input option: " + opt);
                                                }
                                                if (jqInput != null) {
                                                    if (!jqInput.isObject()) {
                                                        throw new JobArgumentException("Input from option [" + opt + "] must be a JSON object. Found: " + jqInput.getNodeType());
                                                    }
                                                    mergedInput.setAll((ObjectNode) jqInput);
                                                }
                                            }

                                        } else {
                                            if (responseBody != null && !response.getResponseBody().trim().isEmpty()) {
                                                if ("application/json".equalsIgnoreCase(contentType)) {
                                                    jqInput = objectMapper.readTree(response.getResponseBody());
                                                    if (!jqInput.isObject()) {
                                                        throw new JobArgumentException("Response body must be a JSON object.");
                                                    }
                                                    mergedInput.setAll((ObjectNode) jqInput);
                                                } else {
                                                    throw new JobArgumentException("Could not create return variable: " + name + " because response body is not in JSON format");
                                                }
                                            } else {
                                                throw new JobArgumentException("Empty response body, could not create return variable: " + name);
                                            }
                                        }
                                        result=ReturnVariableUtils.runJqQuery(mergedInput,jqQuery, rootScope, name);
                                    }
                                    ReturnVariableUtils.writeToFile(step, logger, name, filePath, pI, result, rawOutput, objectMapper);
                                } else if(inputType.equals("plain") && responseBody != null && !response.getResponseBody().trim().isEmpty() && contentType != null && contentType.toLowerCase().startsWith("text/")) {
                                    ReturnVariableUtils.writeToFile(step, logger, name, filePath, pI, responseBody, rawOutput, objectMapper);
                                }
                            }
                        }
                    }
                    else {
                        logger.error("return_variable is not a valid JSON array");
                        step.getOutcome().setReturnCode(1);
                    }
                }
            }
            catch (SOSConnectionRefusedException | SOSBadRequestException e) {
                if (response != null) {
                    step.getOutcome().setReturnCode(response.getStatusCode());
                    logger.error("Request failed: " + response.getStatusCode() + " Body: " + response.getResponseBody());
                }
                throw e;
            } catch (IOException e) {
                logger.error("I/O error during Job execution: " + e.getMessage(), e);
                throw new JobException("I/O Exception occurred: " + e.getMessage(), e);
            }
            finally {
                try {
                    if (accessToken != null) {
                        apiExecutor.logout(accessToken);
                        logoutSuccessful = true;
                    }
                } catch (Exception e) {
                    logger.error("Logout failed: " + e.getMessage(), e);
                    throw e;
                }

                try {
                    apiExecutor.close();
                } catch (Exception e) {
                    logger.error("Failed to close ApiExecutor: " + e.getMessage(), e);
                    throw e;
                }

                if (loginSuccessful && logoutSuccessful) {
                    logger.info("Logout complete.");
                }
            }
        } else {
            throw new JobRequiredArgumentMissingException("Missing request JSON in job arguments.");
        }
    }

    static {
        rootScope = Scope.newEmptyScope(); // create empty root scope
        BuiltinFunctionLoader.getInstance().loadFunctions(Versions.JQ_1_7, rootScope); // load jq built-ins

        objectMapper = new ObjectMapper()
                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
                .configure(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY, true)
                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
                .configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, false);
    }
}
