package com.sos.jitl.jobs.rest;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.sos.commons.httpclient.exception.SOSBadRequestException;
import com.sos.commons.httpclient.exception.SOSConnectionRefusedException;
import com.sos.js7.job.Job;
import com.sos.js7.job.OrderProcessStep;
import com.sos.js7.job.OrderProcessStepLogger;
import com.sos.js7.job.exception.JobArgumentException;
import com.sos.js7.job.exception.JobException;
import com.sos.js7.job.exception.JobRequiredArgumentMissingException;
import com.sos.js7.job.jocapi.ApiExecutor;
import com.sos.js7.job.jocapi.ApiResponse;
import net.thisptr.jackson.jq.JsonQuery;
import net.thisptr.jackson.jq.Scope;
import net.thisptr.jackson.jq.BuiltinFunctionLoader;
import net.thisptr.jackson.jq.Versions;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

public class JS7RESTClientJob extends Job<JS7RESTClientJobArguments> {

    public static final ObjectMapper objectMapper;
    private static final Scope rootScope;

    public void processOrder(OrderProcessStep<JS7RESTClientJobArguments> step) throws Exception {
        JS7RESTClientJobArguments myArgs = step.getDeclaredArguments();
        OrderProcessStepLogger logger = step.getLogger();

        //Check the request JSON
        String requestJson = (String) myArgs.getMyRequest().getValue();
        logger.info("Request Body : " +requestJson);
        if (requestJson != null && !requestJson.isBlank()) {
            JsonNode requestNode;
            try {
                requestNode = objectMapper.readTree(requestJson);
            } catch (Exception e) {
                throw new JobException("Invalid JSON in 'myRequest': " + e.getMessage(), e);
            }

            String endpoint = requestNode.has("endpoint") ? requestNode.get("endpoint").asText(null) : null;
            if (endpoint == null || endpoint.isBlank()) {
                throw new JobRequiredArgumentMissingException("Missing or empty 'endpoint' in request JSON.");
            }

            logger.info("Endpoint: " + endpoint);

            String bodyStr = null;
            if (requestNode.has("body")) {
                try {
                    JsonNode bodyNode = requestNode.get("body");
                    if (bodyNode != null) {
                        bodyStr = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(bodyNode);
                        logger.info("Body:" + bodyStr);
                    }
                } catch (Exception e) {
                    throw new JobException("Failed to extract 'body' from request JSON: " + e.getMessage(), e);
                }
            }

            Map<String, String> headers = new HashMap<>();

            if (requestNode.has("headers") && requestNode.get("headers").isArray()) {
                for (JsonNode headerNode : requestNode.get("headers")) {
                    if (headerNode.has("key") && headerNode.has("value")) {
                        String key = headerNode.get("key").asText();
                        String value = headerNode.get("value").asText();
                        headers.put(key, value);
                    }
                }
            }


            ApiExecutor apiExecutor = new ApiExecutor(step,headers);
            String accessToken = null;
            ApiResponse response = null;
            boolean loginSuccessful = false;
            boolean logoutSuccessful = false;

            try {
                //REST Call -Creating a new session by login method
                response = apiExecutor.login();
                if (response == null || response.getStatusCode() != 200) {
                    String body = response != null ? response.getResponseBody() : "No response";
                    throw new JobException("Login failed. " + body);
                }
                loginSuccessful = true;
                logger.info("Login successful.");

                accessToken = response.getAccessToken();

                //Sending the REST request to the specified endpoint with body and access_token( generated by login in new session)
                response = apiExecutor.post(accessToken, endpoint, bodyStr);
                int statusCode = response.getStatusCode();

                if (statusCode < 200 || statusCode >= 300) {
                    logger.error("Request failed with status code: " + statusCode + ". Response: " + response.getResponseBody());
                    if (statusCode == 420) {
                        throw new JobException("JS7 API Throttling (420): " + response.getResponseBody());
                    }
                    throw new JobException("Unexpected status code: " + statusCode);
                }

                logger.info("REST call successful. Status Code: " + statusCode);

                String targetFilePath = (String) step.getOutcome().getVariables().get("js7ApiExecutorOutfile");
                if (targetFilePath != null && !targetFilePath.isEmpty() && Files.exists(Paths.get(targetFilePath))) {
                    logger.info("Export to File: " + targetFilePath);
                }

                // Extract content-type header (case-insensitive)
                Map<String, String> resHeaders = apiExecutor.getResponseHeaders();
                String contentType = null;
                for (Map.Entry<String, String> entry : resHeaders.entrySet()) {
                    if ("content-type".equalsIgnoreCase(entry.getKey())) {
                        contentType = entry.getValue();
                        break;
                    }
                }
                if (!resHeaders.isEmpty()) {
                    StringBuilder headerLog = new StringBuilder("Response Headers:\n");
                    resHeaders.forEach((key, value) -> headerLog.append("  ").append(key).append(": ").append(value).append("\n"));
                    logger.info(headerLog.toString().trim());
                }

                String jqQuery = null;
                String pI = null;
                String filePath = null;
                String name = null;
                String path = null;
                JsonNode responseJson = null;
                String inputOption = null;
                boolean rawOutput = false;
                String returnVarJson = myArgs.getReturnVariable().getValue();

                if (response.getResponseBody() != null && !response.getResponseBody().trim().isEmpty()) {
                    if ("application/json".equalsIgnoreCase(contentType)) {
                        responseJson = objectMapper.readTree(response.getResponseBody());
                        logger.debug("Response Body: " + objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(responseJson));
                    } else {
                        logger.debug("Response Body : \n" + response.getResponseBody());
                    }
                }

                //Return variable -
                // check if return variable is available or not
                if (returnVarJson != null && !returnVarJson.trim().isEmpty()) {
                    JsonNode returnVars;
                    try {
                        returnVars = objectMapper.readTree(returnVarJson);
                    } catch (Exception e) {
                        throw new JobException("Invalid JSON in 'return_variable': " + e.getMessage(), e);
                    }

                    //check if it is a valid json array or not
                    if (returnVars.isArray()) {

                        ReturnVariableUtils.checkDuplicateReturnVariable(returnVars);
                        for (JsonNode mappingNode : returnVars) {
                            jqQuery = null;
                            pI = null;
                            filePath = null;
                            name = null;
                            path = null;
                            inputOption = null;
                            rawOutput = false;

                            name = mappingNode.has("name") ? mappingNode.get("name").asText().trim() : null;
                            path = mappingNode.has("path") ? mappingNode.get("path").asText().trim() : null;

                            //check if the JSON object have both name and path then fetch the input, output operation and jq query from path
                            if (name != null && !name.isBlank() && path != null && !path.isBlank()) {
                                if (path.startsWith("<")) {
                                    // Case: starts with input option
                                    int firstSeparator = path.indexOf("||");
                                    if (firstSeparator == -1) {
                                        throw new JobArgumentException("Could not create return variable: " + name +
                                                ". Invalid path format: Missing '||' after input option: " + path);
                                    }
                                    inputOption = path.substring(1, firstSeparator).trim(); // Skip '<'
                                    path = path.substring(firstSeparator + 2).trim();        // Remaining path: jq query + file ops
                                }

                                // Split path into jq query and optional processing instructions
                                String[] parts = path.split("\\|\\|", 2);
                                jqQuery = parts[0].trim();

                                if (parts.length > 1) {
                                    // Handle processing flags like -r, > file, etc.
                                    String[] processorParts = parts[1].trim().split("\\s+");
                                    for (int i = 0; i < processorParts.length; i++) {
                                        String token = processorParts[i].trim();

                                        if (token.equals("-r") || token.equals("--raw-output")) {
                                            rawOutput = true;
                                        } else if ((token.equals(">") || token.equals(">>")) && i + 1 < processorParts.length) {
                                            String potentialFilePath = processorParts[i + 1].trim();
                                            if (potentialFilePath.startsWith("-")) {
                                                throw new JobArgumentException("Could not create return variable: " + name +
                                                        ". Invalid file path: found flag instead of file name after '" + token + "'");
                                            }
                                            pI = token;
                                            filePath = potentialFilePath;
                                            i++;
                                        } else if (token.matches("^[A-Za-z]:\\\\.*|^/.*")) {
                                            throw new JobArgumentException("File path provided without Processing Instruction (>, >>): " + token);
                                        }
                                    }
                                }
                            } else {
                                throw new JobArgumentException("Could not create return variable: name or path value is/are invalid or empty");
                            }

                            //assigning the input for jq
                            // Support multiple input options separated by space
                            String[] inputOptions = new String[0];
                            if (inputOption != null && !inputOption.trim().isEmpty()) {
                                inputOptions = inputOption.trim().split("\\s+");
                            }
                            ObjectNode mergedInput = objectMapper.createObjectNode();
                            JsonNode jqInput = null;


                            if (inputOptions.length > 0) {
                                if (response.getResponseBody() != null && !response.getResponseBody().trim().isEmpty()) {
                                    if ("application/json".equalsIgnoreCase(contentType)) {
                                        jqInput = objectMapper.readTree(response.getResponseBody());
                                        if (jqInput.isObject()) {
                                            mergedInput.setAll((ObjectNode) jqInput);
                                        }
                                    }
                                }
                            for (String opt : inputOptions) {
                                if (opt.startsWith("--response-header=") || opt.startsWith("-s=")) {
                                    String headerName = opt.startsWith("--response-header=")
                                            ? opt.substring("--response-header=".length()).trim()
                                            : opt.substring("-s=".length()).trim();

                                    String headerValue = resHeaders.entrySet().stream()
                                            .filter(e -> e.getKey().equalsIgnoreCase(headerName))
                                            .map(Map.Entry::getValue)
                                            .findFirst().orElse(null);

                                    if (headerValue != null) {
                                        ObjectNode headerNode = objectMapper.createObjectNode();
                                        headerNode.put(headerName, headerValue);
                                        ObjectNode wrapper = objectMapper.createObjectNode();
                                        wrapper.set("js7ResponseHeader", headerNode);
                                        jqInput = wrapper;
                                    } else {
                                        throw new JobArgumentException("Could not create return variable: " + name + " because response header not found: " + headerName);
                                    }

                                } else if (opt.equals("--response-header") || opt.equals("-s")) {
                                    ObjectNode headerObject = objectMapper.createObjectNode();
                                    for (Map.Entry<String, String> entry : resHeaders.entrySet()) {
                                        headerObject.put(entry.getKey(), entry.getValue());
                                    }
                                    mergedInput.set("js7ResponseHeader", headerObject);

                                } else if (opt.startsWith("--request-header=") || opt.startsWith("-q=")) {
                                    String headerName = opt.startsWith("--request-header=")
                                            ? opt.substring("--request-header=".length()).trim()
                                            : opt.substring("-q=".length()).trim();

                                    String headerValue = headers.entrySet().stream()
                                            .filter(e -> e.getKey().equalsIgnoreCase(headerName))
                                            .map(Map.Entry::getValue)
                                            .findFirst().orElse(null);

                                    if (headerValue != null) {
                                        ObjectNode headerNode = objectMapper.createObjectNode();
                                        headerNode.put(headerName, headerValue);
                                        ObjectNode wrapper = objectMapper.createObjectNode();
                                        wrapper.set("js7RequestHeader", headerNode);
                                        jqInput = wrapper;
                                    } else {
                                        throw new JobArgumentException("Could not create return variable: " + name + " because request header not found: " + headerName);
                                    }

                                } else if (opt.equals("--request-header") || opt.equals("-q")) {
                                    ObjectNode headerObject = objectMapper.createObjectNode();
                                    for (Map.Entry<String, String> entry : headers.entrySet()) {
                                        headerObject.put(entry.getKey(), entry.getValue());
                                    }
                                    mergedInput.set("js7RequestHeader", headerObject);

                                } else if (opt.equals("--request-body") || opt.equals("-d")) {
                                    if (bodyStr != null && !bodyStr.trim().isEmpty()) {
                                        JsonNode requestBodyJson = objectMapper.readTree(bodyStr);
                                        if (!requestBodyJson.isObject()) {
                                            throw new JobArgumentException("Request body must be a JSON object. Found: " + requestBodyJson.getNodeType());
                                        }
                                        mergedInput.set("js7RequestBody", requestBodyJson);
                                    } else {
                                        throw new JobArgumentException("Empty request body, could not create return variable: " + name);
                                    }

                                } else if (opt.startsWith("--from-json=") || opt.startsWith("-j=")) {
                                    String jsonStr = opt.substring(opt.indexOf('=') + 1).trim();
                                    try {
                                        JsonNode fromJsonNode = objectMapper.readTree(jsonStr);

                                        if (!fromJsonNode.isObject()) {
                                            throw new JobArgumentException(" Expected JSON object for --from-json, but found: " + fromJsonNode.getNodeType());
                                        }

                                        // Check for duplicate keys before merging
                                        Iterator<String> fieldNames = fromJsonNode.fieldNames();
                                        while (fieldNames.hasNext()) {
                                            String fieldName = fieldNames.next();
                                            if (mergedInput.has(fieldName)) {
                                                throw new JobArgumentException("Key conflict during input merge: " + fieldName);
                                            }
                                        }

                                        ((ObjectNode) mergedInput).setAll((ObjectNode) fromJsonNode);

                                    } catch (Exception e) {
                                        logger.error("Invalid JSON for input option: " + jsonStr, e);
                                        throw e;
                                    }
                                }
                                else {
                                    throw new JobArgumentException("Could not create return variable: " + name + ". Unsupported input option: " + opt);
                                }

                                if (jqInput != null) {
                                    if (!jqInput.isObject()) {
                                        throw new JobArgumentException("Input from option [" + opt + "] must be a JSON object. Found: " + jqInput.getNodeType());
                                    }
                                    mergedInput.setAll((ObjectNode) jqInput);
                                }
                            }
                            }else{
                                if (response.getResponseBody() != null && !response.getResponseBody().trim().isEmpty()) {
                                    if ("application/json".equalsIgnoreCase(contentType)) {
                                        jqInput = objectMapper.readTree(response.getResponseBody());
                                        if (!jqInput.isObject()) {
                                            throw new JobArgumentException("Response body must be a JSON object.");
                                        }
                                        mergedInput.setAll((ObjectNode) jqInput);
                                    } else {
                                        throw new JobArgumentException("Could not create return variable: " + name + " because response body is not in JSON format");
                                    }
                                } else {
                                    throw new JobArgumentException("Empty response body, could not create return variable: " + name);
                                }
                            }

                            // mergedInput is now ready to be used for jq query execution
                            if (mergedInput != null && !mergedInput.isEmpty()) {
                                JsonQuery query = JsonQuery.compile(jqQuery, Versions.JQ_1_7);
                                List<JsonNode> out = new ArrayList<>();
                                query.apply(rootScope, mergedInput, out::add);

                                if (!out.isEmpty() && out.stream().anyMatch(node -> !node.isNull())) {

                                    if (filePath != null) {
                                        File file = new File(filePath);
                                        File parent = file.getParentFile();
                                        if (parent != null && !parent.exists()) {
                                            parent.mkdirs();
                                        }

                                        boolean append = ">>".equals(pI);

                                        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, append))) {
                                            for (JsonNode outputNode : out) {
                                                if (rawOutput && outputNode.isTextual()) {
                                                    writer.write(outputNode.asText());
                                                } else {
                                                    writer.write(objectMapper.writeValueAsString(outputNode));
                                                }
                                                writer.newLine();
                                            }
                                        }

                                        logger.info("Result written to file successfully.");
                                        step.getOutcome().getVariables().put(name, filePath);
                                        logger.info("Assigned return variable: " + name + " = " + filePath);
                                    } else {
                                        // If NOT writing to file, store result directly
                                        if (rawOutput && out.size() == 1 && out.get(0).isTextual()) {
                                            String raw = out.get(0).asText();
                                            step.getOutcome().getVariables().put(name, raw);
                                            logger.info("Assigned return variable: " + name + " = " + raw);
                                        } else {
                                            JsonNode resultNode = out.size() == 1 ? out.get(0) : objectMapper.valueToTree(out);
                                            String resultPretty = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(resultNode);
                                            step.getOutcome().getVariables().put(name, resultPretty);
                                            logger.info("Assigned return variable: " + name + " = " + resultPretty);
                                        }
                                    }
                                } else {
                                    throw new JobArgumentException("Error in extracting return variable " + name + " from jq Query " + jqQuery);
                                }
                            }else{
                                throw new JobArgumentException("Error in extracting return variable " + name + " from jq Query " + jqQuery);
                            }
                        }
                    }
                    else {
                        logger.error("return_variable is not a valid JSON array");
                        step.getOutcome().setReturnCode(1);
                    }
                }
            }
            catch (SOSConnectionRefusedException | SOSBadRequestException e) {
                if (response != null) {
                    step.getOutcome().setReturnCode(response.getStatusCode());
                    logger.error("Request failed: " + response.getStatusCode() + " Body: " + response.getResponseBody());
                }
                throw e;
            } catch (IOException e) {
                logger.error("I/O error during REST call: " + e.getMessage(), e);
                throw new JobException("REST call failed due to I/O error: " + e.getMessage(), e);
            }
            finally {
                try {
                    if (accessToken != null) {
                        apiExecutor.logout(accessToken);
                        logoutSuccessful = true;
                    }
                } catch (Exception e) {
                    logger.error("Logout failed: " + e.getMessage(), e);
                    throw e;
                }

                try {
                    apiExecutor.close();
                } catch (Exception e) {
                    logger.error("Failed to close ApiExecutor: " + e.getMessage(), e);
                    throw e;
                }

                if (loginSuccessful && logoutSuccessful) {
                    logger.info("Logout complete.");
                }
            }
        } else {
            throw new JobRequiredArgumentMissingException("Missing request JSON in job arguments.");
        }
    }

    static {
        rootScope = Scope.newEmptyScope(); // create empty root scope
        BuiltinFunctionLoader.getInstance().loadFunctions(Versions.JQ_1_7, rootScope); // load jq built-ins

        objectMapper = new ObjectMapper()
                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
                .configure(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY, true)
                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
                .configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, false);
    }
}
